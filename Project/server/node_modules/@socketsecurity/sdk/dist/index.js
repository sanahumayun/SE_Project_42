import events from 'node:events';
import { createReadStream, createWriteStream } from 'node:fs';
import http from 'node:http';
import https from 'node:https';
import path from 'node:path';
import readline from 'node:readline';
import abortSignal from '@socketsecurity/registry/lib/constants/abort-signal';
// @ts-ignore
import rootPkgJson from '../package.json' with { type: 'json' };
const DEFAULT_USER_AGENT = createUserAgentFromPkgJson(rootPkgJson);
class ResponseError extends Error {
    response;
    constructor(response, message = '') {
        const statusCode = response.statusCode ?? 'unknown';
        const statusMessage = response.statusMessage ?? 'No status message';
        super(`Socket API ${message || 'Request failed'} (${statusCode}): ${statusMessage}`);
        this.name = 'ResponseError';
        this.response = response;
        Error.captureStackTrace(this, ResponseError);
    }
}
async function createDeleteRequest(baseUrl, urlPath, options) {
    const req = getHttpModule(baseUrl)
        .request(`${baseUrl}${urlPath}`, {
        method: 'DELETE',
        ...options
    })
        .end();
    return await getResponse(req);
}
async function createGetRequest(baseUrl, urlPath, options) {
    const req = getHttpModule(baseUrl)
        .request(`${baseUrl}${urlPath}`, {
        method: 'GET',
        ...options
    })
        .end();
    return await getResponse(req);
}
async function createPostRequest(baseUrl, urlPath, postJson, options) {
    const req = getHttpModule(baseUrl)
        .request(`${baseUrl}${urlPath}`, {
        method: 'POST',
        ...options
    })
        .end(JSON.stringify(postJson));
    return await getResponse(req);
}
function createRequestBodyForFilepaths(filepaths, basePath) {
    const requestBody = [];
    for (const absPath of filepaths) {
        const relPath = path.relative(basePath, absPath);
        const filename = path.basename(absPath);
        requestBody.push(`Content-Disposition: form-data; name="${relPath}"; filename="${filename}"\r\n`, `Content-Type: application/octet-stream\r\n\r\n`, createReadStream(absPath));
    }
    return requestBody;
}
function createRequestBodyForJson(jsonData, basename = 'data.json') {
    const ext = path.extname(basename);
    const name = path.basename(basename, ext);
    return [
        `Content-Disposition: form-data; name="${name}"; filename="${basename}"\r\n`,
        'Content-Type: application/json\r\n\r\n',
        JSON.stringify(jsonData),
        // New line after file content.
        '\r\n'
    ];
}
async function createUploadRequest(baseUrl, urlPath, requestBodyNoBoundaries, options) {
    // Generate a unique boundary for multipart encoding.
    const boundary = `NodeMultipartBoundary${Date.now()}`;
    const boundarySep = `--${boundary}\r\n`;
    const finalBoundary = `--${boundary}--\r\n`;
    const requestBody = [
        ...requestBodyNoBoundaries.flatMap(part => [
            boundarySep,
            ...(Array.isArray(part) ? part : [part])
        ]),
        finalBoundary
    ];
    const req = getHttpModule(baseUrl).request(`${baseUrl}${urlPath}`, {
        method: 'POST',
        ...options,
        headers: {
            ...options?.headers,
            'Content-Type': `multipart/form-data; boundary=${boundary}`
        }
    });
    try {
        // Send the request body (headers + files).
        for (const part of requestBody) {
            if (typeof part === 'string') {
                req.write(part);
            }
            else if (typeof part?.pipe === 'function') {
                part.pipe(req, { end: false });
                // Wait for file streaming to complete.
                // eslint-disable-next-line no-await-in-loop
                await events.once(part, 'end');
                // Ensure a new line after file content.
                req.write('\r\n');
            }
            else {
                throw new TypeError('Socket API - Invalid multipart part, expected string or stream');
            }
        }
    }
    finally {
        // Close request after writing all data.
        req.end();
    }
    return await getResponse(req);
}
function getHttpModule(baseUrl) {
    const { protocol } = new URL(baseUrl);
    return protocol === 'https:' ? https : http;
}
async function getResponse(req) {
    try {
        const { 0: res } = (await events.once(req, 'response', {
            signal: abortSignal
        }));
        if (!isResponseOk(res)) {
            throw new ResponseError(res, `${req.method} request failed`);
        }
        return res;
    }
    catch (e) {
        req.destroy();
        throw e;
    }
}
async function getResponseJson(response) {
    let data = '';
    for await (const chunk of response) {
        data += chunk;
    }
    try {
        return JSON.parse(data);
    }
    catch (e) {
        throw new SyntaxError(`Socket API - Invalid JSON response:\n${data}\nâ†’ ${e?.message || 'Unknown error'}`, { cause: e });
    }
}
function isResponseOk(response) {
    const { statusCode } = response;
    return (typeof statusCode === 'number' && statusCode >= 200 && statusCode <= 299);
}
function resolveAbsPaths(filepaths, pathsRelativeTo) {
    const basePath = resolveBasePath(pathsRelativeTo);
    // Node's path.resolve will process path segments from right to left until
    // it creates a valid absolute path. So if `pathsRelativeTo` is an absolute
    // path, process.cwd() is not used, which is the common expectation. If none
    // of the paths resolve then it defaults to process.cwd().
    return filepaths.map(p => path.resolve(basePath, p));
}
function resolveBasePath(pathsRelativeTo = '.') {
    // Node's path.resolve will process path segments from right to left until
    // it creates a valid absolute path. So if `pathsRelativeTo` is an absolute
    // path, process.cwd() is not used, which is the common expectation. If none
    // of the paths resolve then it defaults to process.cwd().
    return path.resolve(process.cwd(), pathsRelativeTo);
}
/**
 * Package.json data to base the User-Agent on
 */
export function createUserAgentFromPkgJson(pkgData) {
    const { homepage } = pkgData;
    const name = pkgData.name.replace('@', '').replace('/', '-');
    return `${name}/${pkgData.version}${homepage ? ` (${homepage})` : ''}`;
}
// https://github.com/sindresorhus/got/blob/v14.4.6/documentation/2-options.md#agent
const agentNames = new Set(['http', 'https', 'http2']);
export class SocketSdk {
    #baseUrl;
    #reqOptions;
    /**
     * @throws {SocketSdkAuthError}
     */
    constructor(apiToken, options) {
        const { agent: agentOrObj, baseUrl = 'https://api.socket.dev/v0/', userAgent } = { __proto__: null, ...options };
        const agentKeys = agentOrObj ? Object.keys(agentOrObj) : [];
        const agent = (agentKeys.length && agentKeys.every(k => agentNames.has(k))
            ? agentOrObj.https
            : agentOrObj);
        this.#baseUrl = baseUrl;
        this.#reqOptions = {
            ...(agent ? { agent } : {}),
            headers: {
                Authorization: `Basic ${btoa(`${apiToken}:`)}`,
                'User-Agent': userAgent ?? DEFAULT_USER_AGENT
            },
            signal: abortSignal
        };
    }
    async #createBatchPurlRequest(queryParams, componentsObj) {
        // Adds the first 'abort' listener to abortSignal.
        const req = getHttpModule(this.#baseUrl)
            .request(`${this.#baseUrl}purl?${new URLSearchParams(queryParams ?? '')}`, {
            method: 'POST',
            ...this.#reqOptions
        })
            .end(JSON.stringify(componentsObj));
        return await getResponse(req);
    }
    async *#createBatchPurlGenerator(queryParams, componentsObj) {
        let res;
        try {
            res = await this.#createBatchPurlRequest(queryParams, componentsObj);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
        const rli = readline.createInterface({
            input: res,
            crlfDelay: Infinity,
            signal: abortSignal
        });
        for await (const line of rli) {
            yield this.#handleApiSuccess(JSON.parse(line));
        }
    }
    #handleApiError(error) {
        if (!(error instanceof ResponseError)) {
            throw new Error('Unexpected Socket API error', {
                cause: error
            });
        }
        const statusCode = error.response.statusCode;
        if (statusCode >= 500) {
            throw new Error(`Socket API server error (${statusCode})`, {
                cause: error
            });
        }
        return {
            success: false,
            status: statusCode,
            error: error.message ?? ''
        };
    }
    #handleApiSuccess(data) {
        return {
            success: true,
            status: 200,
            data: data
        };
    }
    async batchPackageFetch(queryParams, componentsObj) {
        let res;
        try {
            res = await this.#createBatchPurlRequest(queryParams, componentsObj);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
        // Parse the newline delimited JSON response.
        const rl = readline.createInterface({
            input: res,
            crlfDelay: Infinity
        });
        const results = [];
        for await (const line of rl) {
            if (line.trim()) {
                results.push(JSON.parse(line));
            }
        }
        return this.#handleApiSuccess(results);
    }
    async *batchPackageStream(queryParams, componentsObj, options) {
        const { chunkSize = 5, concurrencyLimit = 10 } = {
            __proto__: null,
            ...options
        };
        // The createBatchPurlGenerator method will add 2 'abort' event listeners to
        // abortSignal so we multiply the concurrencyLimit by 2.
        const neededMaxListeners = concurrencyLimit * 2;
        // Increase abortSignal max listeners count to avoid Node's MaxListenersExceededWarning.
        const oldAbortSignalMaxListeners = events.getMaxListeners(abortSignal);
        let abortSignalMaxListeners = oldAbortSignalMaxListeners;
        if (oldAbortSignalMaxListeners < neededMaxListeners) {
            abortSignalMaxListeners = oldAbortSignalMaxListeners + neededMaxListeners;
            events.setMaxListeners(abortSignalMaxListeners, abortSignal);
        }
        const { components } = componentsObj;
        const { length: componentsCount } = components;
        const running = [];
        let index = 0;
        const enqueueGen = () => {
            if (index >= componentsCount) {
                // No more work to do.
                return;
            }
            const generator = this.#createBatchPurlGenerator(queryParams, {
                // Chunk components.
                components: components.slice(index, index + chunkSize)
            });
            continueGen(generator);
            index += chunkSize;
        };
        const continueGen = (generator) => {
            let resolveFn;
            running.push({
                generator,
                promise: new Promise(resolve => (resolveFn = resolve))
            });
            void generator
                .next()
                .then(iteratorResult => resolveFn({ generator, iteratorResult }));
        };
        // Start initial batch of generators.
        while (running.length < concurrencyLimit && index < componentsCount) {
            enqueueGen();
        }
        while (running.length > 0) {
            // eslint-disable-next-line no-await-in-loop
            const { generator, iteratorResult } = await Promise.race(running.map(entry => entry.promise));
            // Remove generator.
            running.splice(running.findIndex(entry => entry.generator === generator), 1);
            if (iteratorResult.done) {
                // Start a new generator if available.
                enqueueGen();
            }
            else {
                yield iteratorResult.value;
                // Keep fetching values from this generator.
                continueGen(generator);
            }
        }
        // Reset abortSignal max listeners count.
        if (abortSignalMaxListeners > oldAbortSignalMaxListeners) {
            events.setMaxListeners(oldAbortSignalMaxListeners, abortSignal);
        }
    }
    async createDependenciesSnapshot(params, filepaths, pathsRelativeTo = '.') {
        const basePath = resolveBasePath(pathsRelativeTo);
        const absFilepaths = resolveAbsPaths(filepaths, basePath);
        try {
            const data = await getResponseJson(await createUploadRequest(this.#baseUrl, `dependencies/upload?${new URLSearchParams(params)}`, createRequestBodyForFilepaths(absFilepaths, basePath), this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async createOrgFullScan(orgSlug, queryParams, filepaths, pathsRelativeTo = '.') {
        const basePath = resolveBasePath(pathsRelativeTo);
        const absFilepaths = resolveAbsPaths(filepaths, basePath);
        try {
            const data = await getResponseJson(await createUploadRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans?${new URLSearchParams(queryParams ?? '')}`, createRequestBodyForFilepaths(absFilepaths, basePath), this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async createOrgRepo(orgSlug, params) {
        try {
            const data = await getResponseJson(await createPostRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos`, { json: params }, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async createReportFromFilepaths(filepaths, pathsRelativeTo = '.', issueRules) {
        const basePath = resolveBasePath(pathsRelativeTo);
        const absFilepaths = resolveAbsPaths(filepaths, basePath);
        try {
            const data = await createUploadRequest(this.#baseUrl, 'report/upload', [
                ...createRequestBodyForFilepaths(absFilepaths, basePath),
                ...(issueRules
                    ? createRequestBodyForJson(issueRules, 'issueRules')
                    : [])
            ], {
                ...this.#reqOptions,
                method: 'PUT'
            });
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    // Alias to preserve backwards compatibility.
    async createReportFromFilePaths(filepaths, pathsRelativeTo = '.', issueRules) {
        return await this.createReportFromFilepaths(filepaths, pathsRelativeTo, issueRules);
    }
    async deleteOrgFullScan(orgSlug, fullScanId) {
        try {
            const data = await getResponseJson(await createDeleteRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async deleteOrgRepo(orgSlug, repoSlug) {
        try {
            const data = await getResponseJson(await createDeleteRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos/${encodeURIComponent(repoSlug)}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getAuditLogEvents(orgSlug, queryParams) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/audit-log?${new URLSearchParams(queryParams ?? '')}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getIssuesByNPMPackage(pkgName, version) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `npm/${encodeURIComponent(pkgName)}/${encodeURIComponent(version)}/issues`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgAnalytics(time) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `analytics/org/${encodeURIComponent(time)}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrganizations() {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'organizations', this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgFullScan(orgSlug, fullScanId, file) {
        try {
            const req = getHttpModule(this.#baseUrl)
                .request(`${this.#baseUrl}orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}`, {
                method: 'GET',
                ...this.#reqOptions
            })
                .end();
            const res = await getResponse(req);
            if (file) {
                res.pipe(createWriteStream(file));
            }
            else {
                res.pipe(process.stdout);
            }
            return this.#handleApiSuccess(res);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgFullScanList(orgSlug, queryParams) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans?${new URLSearchParams(queryParams ?? '')}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgFullScanMetadata(orgSlug, fullScanId) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/full-scans/${encodeURIComponent(fullScanId)}/metadata`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgLicensePolicy(orgSlug) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/settings/license-policy`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgRepo(orgSlug, repoSlug) {
        const orgSlugParam = encodeURIComponent(orgSlug);
        const repoSlugParam = encodeURIComponent(repoSlug);
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${orgSlugParam}/repos/${repoSlugParam}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgRepoList(orgSlug, queryParams) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos?${new URLSearchParams(queryParams ?? '')}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getOrgSecurityPolicy(orgSlug) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/settings/security-policy`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getQuota() {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'quota', this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getRepoAnalytics(repo, time) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `analytics/repo/${encodeURIComponent(repo)}/${encodeURIComponent(time)}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getReport(id) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `report/view/${encodeURIComponent(id)}`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getReportList() {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'report/list', this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getReportSupportedFiles() {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, 'report/supported', this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async getScoreByNPMPackage(pkgName, version) {
        try {
            const data = await getResponseJson(await createGetRequest(this.#baseUrl, `npm/${encodeURIComponent(pkgName)}/${encodeURIComponent(version)}/score`, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async postSettings(selectors) {
        try {
            const data = await getResponseJson(await createPostRequest(this.#baseUrl, 'settings', { json: selectors }, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async searchDependencies(params) {
        try {
            const data = await getResponseJson(await createPostRequest(this.#baseUrl, 'dependencies/search', { json: params }, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
    async updateOrgRepo(orgSlug, repoSlug, params) {
        try {
            const data = await getResponseJson(await createPostRequest(this.#baseUrl, `orgs/${encodeURIComponent(orgSlug)}/repos/${encodeURIComponent(repoSlug)}`, { json: params }, this.#reqOptions));
            return this.#handleApiSuccess(data);
        }
        catch (e) {
            return this.#handleApiError(e);
        }
    }
}
//# sourceMappingURL=index.js.map