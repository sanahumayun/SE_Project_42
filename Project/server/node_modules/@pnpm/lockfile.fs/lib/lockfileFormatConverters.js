"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToLockfileFile = convertToLockfileFile;
exports.convertToLockfileObject = convertToLockfileObject;
const dependency_path_1 = require("@pnpm/dependency-path");
const types_1 = require("@pnpm/types");
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const map_1 = __importDefault(require("ramda/src/map"));
const omit_1 = __importDefault(require("ramda/src/omit"));
const pickBy_1 = __importDefault(require("ramda/src/pickBy"));
const pick_1 = __importDefault(require("ramda/src/pick"));
const constants_1 = require("@pnpm/constants");
function convertToLockfileFile(lockfile) {
    const packages = {};
    const snapshots = {};
    for (const [depPath, pkg] of Object.entries(lockfile.packages ?? {})) {
        snapshots[depPath] = (0, pick_1.default)([
            'dependencies',
            'optionalDependencies',
            'transitivePeerDependencies',
            'optional',
            'id',
        ], pkg);
        const pkgId = (0, dependency_path_1.removeSuffix)(depPath);
        if (!packages[pkgId]) {
            packages[pkgId] = (0, pick_1.default)([
                'bundledDependencies',
                'cpu',
                'deprecated',
                'engines',
                'hasBin',
                'libc',
                'name',
                'os',
                'peerDependencies',
                'peerDependenciesMeta',
                'resolution',
                'version',
            ], pkg);
        }
    }
    const newLockfile = {
        ...lockfile,
        snapshots,
        packages,
        lockfileVersion: constants_1.LOCKFILE_VERSION,
        importers: mapValues(lockfile.importers, convertProjectSnapshotToInlineSpecifiersFormat),
    };
    if (newLockfile.settings?.peersSuffixMaxLength === 1000) {
        newLockfile.settings = (0, omit_1.default)(['peersSuffixMaxLength'], newLockfile.settings);
    }
    if (newLockfile.settings?.injectWorkspacePackages === false) {
        delete newLockfile.settings.injectWorkspacePackages;
    }
    return normalizeLockfile(newLockfile);
}
function normalizeLockfile(lockfile) {
    const lockfileToSave = {
        ...lockfile,
        importers: (0, map_1.default)((importer) => {
            const normalizedImporter = {};
            if (importer.dependenciesMeta != null && !(0, isEmpty_1.default)(importer.dependenciesMeta)) {
                normalizedImporter.dependenciesMeta = importer.dependenciesMeta;
            }
            for (const depType of types_1.DEPENDENCIES_FIELDS) {
                if (!(0, isEmpty_1.default)(importer[depType] ?? {})) {
                    normalizedImporter[depType] = importer[depType];
                }
            }
            if (importer.publishDirectory) {
                normalizedImporter.publishDirectory = importer.publishDirectory;
            }
            return normalizedImporter;
        }, lockfile.importers ?? {}),
    };
    if ((0, isEmpty_1.default)(lockfileToSave.packages) || (lockfileToSave.packages == null)) {
        delete lockfileToSave.packages;
    }
    if ((0, isEmpty_1.default)(lockfileToSave.snapshots) || (lockfileToSave.snapshots == null)) {
        delete lockfileToSave.snapshots;
    }
    if (lockfileToSave.time) {
        lockfileToSave.time = pruneTimeInLockfile(lockfileToSave.time, lockfile.importers ?? {});
    }
    if ((lockfileToSave.catalogs != null) && (0, isEmpty_1.default)(lockfileToSave.catalogs)) {
        delete lockfileToSave.catalogs;
    }
    if ((lockfileToSave.overrides != null) && (0, isEmpty_1.default)(lockfileToSave.overrides)) {
        delete lockfileToSave.overrides;
    }
    if ((lockfileToSave.patchedDependencies != null) && (0, isEmpty_1.default)(lockfileToSave.patchedDependencies)) {
        delete lockfileToSave.patchedDependencies;
    }
    if (!lockfileToSave.packageExtensionsChecksum) {
        delete lockfileToSave.packageExtensionsChecksum;
    }
    if (!lockfileToSave.ignoredOptionalDependencies?.length) {
        delete lockfileToSave.ignoredOptionalDependencies;
    }
    if (!lockfileToSave.pnpmfileChecksum) {
        delete lockfileToSave.pnpmfileChecksum;
    }
    return lockfileToSave;
}
function pruneTimeInLockfile(time, importers) {
    const rootDepPaths = new Set();
    for (const importer of Object.values(importers)) {
        for (const depType of types_1.DEPENDENCIES_FIELDS) {
            for (const [depName, ref] of Object.entries(importer[depType] ?? {})) {
                const suffixStart = ref.version.indexOf('(');
                const refWithoutPeerSuffix = suffixStart === -1 ? ref.version : ref.version.slice(0, suffixStart);
                const depPath = refToRelative(refWithoutPeerSuffix, depName);
                if (!depPath)
                    continue;
                rootDepPaths.add(depPath);
            }
        }
    }
    return (0, pickBy_1.default)((_, depPath) => rootDepPaths.has(depPath), time);
}
function refToRelative(reference, pkgName) {
    if (reference.startsWith('link:')) {
        return null;
    }
    if (reference.startsWith('file:')) {
        return reference;
    }
    if (!reference.includes('/') || !reference.replace(/(?:\([^)]+\))+$/, '').includes('/')) {
        return `/${pkgName}@${reference}`;
    }
    return reference;
}
function convertToLockfileObject(lockfile) {
    const { importers, ...rest } = lockfile;
    const packages = {};
    for (const [depPath, pkg] of Object.entries(lockfile.snapshots ?? {})) {
        const pkgId = (0, dependency_path_1.removeSuffix)(depPath);
        packages[depPath] = Object.assign(pkg, lockfile.packages?.[pkgId]);
    }
    return {
        ...(0, omit_1.default)(['snapshots'], rest),
        packages,
        importers: mapValues(importers ?? {}, revertProjectSnapshot),
    };
}
function convertProjectSnapshotToInlineSpecifiersFormat(projectSnapshot) {
    const { specifiers, ...rest } = projectSnapshot;
    if (specifiers == null)
        return projectSnapshot;
    const convertBlock = (block) => block != null
        ? convertResolvedDependenciesToInlineSpecifiersFormat(block, { specifiers })
        : block;
    return {
        ...rest,
        dependencies: convertBlock(projectSnapshot.dependencies ?? {}),
        optionalDependencies: convertBlock(projectSnapshot.optionalDependencies ?? {}),
        devDependencies: convertBlock(projectSnapshot.devDependencies ?? {}),
    };
}
function convertResolvedDependenciesToInlineSpecifiersFormat(resolvedDependencies, { specifiers }) {
    return mapValues(resolvedDependencies, (version, depName) => ({
        specifier: specifiers[depName],
        version,
    }));
}
function revertProjectSnapshot(from) {
    const specifiers = {};
    function moveSpecifiers(from) {
        const resolvedDependencies = {};
        for (const [depName, { specifier, version }] of Object.entries(from)) {
            const existingValue = specifiers[depName];
            if (existingValue != null && existingValue !== specifier) {
                throw new Error(`Project snapshot lists the same dependency more than once with conflicting versions: ${depName}`);
            }
            specifiers[depName] = specifier;
            resolvedDependencies[depName] = version;
        }
        return resolvedDependencies;
    }
    const dependencies = from.dependencies == null
        ? from.dependencies
        : moveSpecifiers(from.dependencies);
    const devDependencies = from.devDependencies == null
        ? from.devDependencies
        : moveSpecifiers(from.devDependencies);
    const optionalDependencies = from.optionalDependencies == null
        ? from.optionalDependencies
        : moveSpecifiers(from.optionalDependencies);
    return {
        ...from,
        specifiers,
        dependencies,
        devDependencies,
        optionalDependencies,
    };
}
function mapValues(obj, mapper) {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        result[key] = mapper(value, key);
    }
    return result;
}
//# sourceMappingURL=lockfileFormatConverters.js.map