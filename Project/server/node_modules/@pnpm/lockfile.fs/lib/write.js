"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeWantedLockfile = writeWantedLockfile;
exports.writeCurrentLockfile = writeCurrentLockfile;
exports.writeLockfileFile = writeLockfileFile;
exports.isEmptyLockfile = isEmptyLockfile;
exports.writeLockfiles = writeLockfiles;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const constants_1 = require("@pnpm/constants");
const rimraf_1 = __importDefault(require("@zkochan/rimraf"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const isEmpty_1 = __importDefault(require("ramda/src/isEmpty"));
const write_file_atomic_1 = __importDefault(require("write-file-atomic"));
const logger_1 = require("./logger");
const sortLockfileKeys_1 = require("./sortLockfileKeys");
const lockfileName_1 = require("./lockfileName");
const lockfileFormatConverters_1 = require("./lockfileFormatConverters");
async function writeFileAtomic(filename, data) {
    return new Promise((resolve, reject) => {
        (0, write_file_atomic_1.default)(filename, data, {}, (err) => {
            (err != null) ? reject(err) : resolve();
        });
    });
}
const LOCKFILE_YAML_FORMAT = {
    blankLines: true,
    lineWidth: -1, // This is setting line width to never wrap
    noCompatMode: true,
    noRefs: true,
    sortKeys: false,
};
async function writeWantedLockfile(pkgPath, wantedLockfile, opts) {
    const wantedLockfileName = await (0, lockfileName_1.getWantedLockfileName)(opts);
    return writeLockfile(wantedLockfileName, pkgPath, wantedLockfile);
}
async function writeCurrentLockfile(virtualStoreDir, currentLockfile) {
    // empty lockfile is not saved
    if (isEmptyLockfile(currentLockfile)) {
        await (0, rimraf_1.default)(path_1.default.join(virtualStoreDir, 'lock.yaml'));
        return;
    }
    await fs_1.promises.mkdir(virtualStoreDir, { recursive: true });
    return writeLockfile('lock.yaml', virtualStoreDir, currentLockfile);
}
async function writeLockfile(lockfileFilename, pkgPath, wantedLockfile) {
    const lockfilePath = path_1.default.join(pkgPath, lockfileFilename);
    const lockfileToStringify = (0, lockfileFormatConverters_1.convertToLockfileFile)(wantedLockfile);
    return writeLockfileFile(lockfilePath, lockfileToStringify);
}
function writeLockfileFile(lockfilePath, wantedLockfile) {
    const yamlDoc = yamlStringify(wantedLockfile);
    return writeFileAtomic(lockfilePath, yamlDoc);
}
function yamlStringify(lockfile) {
    const sortedLockfile = (0, sortLockfileKeys_1.sortLockfileKeys)(lockfile);
    return js_yaml_1.default.dump(sortedLockfile, LOCKFILE_YAML_FORMAT);
}
function isEmptyLockfile(lockfile) {
    return Object.values(lockfile.importers).every((importer) => (0, isEmpty_1.default)(importer.specifiers ?? {}) && (0, isEmpty_1.default)(importer.dependencies ?? {}));
}
async function writeLockfiles(opts) {
    const wantedLockfileName = await (0, lockfileName_1.getWantedLockfileName)(opts);
    const wantedLockfilePath = path_1.default.join(opts.wantedLockfileDir, wantedLockfileName);
    const currentLockfilePath = path_1.default.join(opts.currentLockfileDir, 'lock.yaml');
    const wantedLockfileToStringify = (0, lockfileFormatConverters_1.convertToLockfileFile)(opts.wantedLockfile);
    const yamlDoc = yamlStringify(wantedLockfileToStringify);
    // in most cases the `pnpm-lock.yaml` and `node_modules/.pnpm-lock.yaml` are equal
    // in those cases the YAML document can be stringified only once for both files
    // which is more efficient
    if (opts.wantedLockfile === opts.currentLockfile) {
        await Promise.all([
            writeFileAtomic(wantedLockfilePath, yamlDoc),
            (async () => {
                if (isEmptyLockfile(opts.wantedLockfile)) {
                    await (0, rimraf_1.default)(currentLockfilePath);
                }
                else {
                    await fs_1.promises.mkdir(path_1.default.dirname(currentLockfilePath), { recursive: true });
                    await writeFileAtomic(currentLockfilePath, yamlDoc);
                }
            })(),
        ]);
        return;
    }
    logger_1.lockfileLogger.debug({
        message: `\`${constants_1.WANTED_LOCKFILE}\` differs from \`${path_1.default.relative(opts.wantedLockfileDir, currentLockfilePath)}\``,
        prefix: opts.wantedLockfileDir,
    });
    const currentLockfileToStringify = (0, lockfileFormatConverters_1.convertToLockfileFile)(opts.currentLockfile);
    const currentYamlDoc = yamlStringify(currentLockfileToStringify);
    await Promise.all([
        writeFileAtomic(wantedLockfilePath, yamlDoc),
        (async () => {
            if (isEmptyLockfile(opts.wantedLockfile)) {
                await (0, rimraf_1.default)(currentLockfilePath);
            }
            else {
                await fs_1.promises.mkdir(path_1.default.dirname(currentLockfilePath), { recursive: true });
                await writeFileAtomic(currentLockfilePath, currentYamlDoc);
            }
        })(),
    ]);
}
//# sourceMappingURL=write.js.map