"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortLockfileKeys = sortLockfileKeys;
const object_key_sorting_1 = require("@pnpm/object.key-sorting");
const ORDERED_KEYS = {
    resolution: 1,
    id: 2,
    name: 3,
    version: 4,
    engines: 5,
    cpu: 6,
    os: 7,
    libc: 8,
    deprecated: 9,
    hasBin: 10,
    prepare: 11,
    requiresBuild: 12,
    bundleDependencies: 13,
    peerDependencies: 14,
    peerDependenciesMeta: 15,
    dependencies: 16,
    optionalDependencies: 17,
    transitivePeerDependencies: 18,
    dev: 19,
    optional: 20,
};
const ROOT_KEYS = [
    'lockfileVersion',
    'settings',
    'catalogs',
    'overrides',
    'packageExtensionsChecksum',
    'pnpmfileChecksum',
    'patchedDependencies',
    'importers',
    'packages',
];
const ROOT_KEYS_ORDER = Object.fromEntries(ROOT_KEYS.map((key, index) => [key, index]));
function sortLockfileKeys(lockfile) {
    if (lockfile.importers != null) {
        lockfile.importers = (0, object_key_sorting_1.sortDirectKeys)(lockfile.importers);
        for (const [importerId, importer] of Object.entries(lockfile.importers)) {
            lockfile.importers[importerId] = (0, object_key_sorting_1.sortKeysByPriority)({
                priority: ROOT_KEYS_ORDER,
                deep: true,
            }, importer);
        }
    }
    if (lockfile.packages != null) {
        lockfile.packages = (0, object_key_sorting_1.sortDirectKeys)(lockfile.packages);
        for (const [pkgId, pkg] of Object.entries(lockfile.packages)) {
            lockfile.packages[pkgId] = (0, object_key_sorting_1.sortKeysByPriority)({
                priority: ORDERED_KEYS,
                deep: true,
            }, pkg);
        }
    }
    if (lockfile.snapshots != null) {
        lockfile.snapshots = (0, object_key_sorting_1.sortDirectKeys)(lockfile.snapshots);
        for (const [pkgId, pkg] of Object.entries(lockfile.snapshots)) {
            lockfile.snapshots[pkgId] = (0, object_key_sorting_1.sortKeysByPriority)({
                priority: ORDERED_KEYS,
                deep: true,
            }, pkg);
        }
    }
    if (lockfile.catalogs != null) {
        lockfile.catalogs = (0, object_key_sorting_1.sortDirectKeys)(lockfile.catalogs);
        for (const [catalogName, catalog] of Object.entries(lockfile.catalogs)) {
            lockfile.catalogs[catalogName] = (0, object_key_sorting_1.sortDeepKeys)(catalog);
        }
    }
    for (const key of ['time', 'patchedDependencies']) {
        if (!lockfile[key])
            continue;
        lockfile[key] = (0, object_key_sorting_1.sortDirectKeys)(lockfile[key]); // eslint-disable-line @typescript-eslint/no-explicit-any
    }
    return (0, object_key_sorting_1.sortKeysByPriority)({ priority: ROOT_KEYS_ORDER }, lockfile);
}
//# sourceMappingURL=sortLockfileKeys.js.map