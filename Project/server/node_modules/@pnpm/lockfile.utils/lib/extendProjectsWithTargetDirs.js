"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendProjectsWithTargetDirs = extendProjectsWithTargetDirs;
const path_1 = __importDefault(require("path"));
const dependency_path_1 = require("@pnpm/dependency-path");
const packageIdFromSnapshot_1 = require("./packageIdFromSnapshot");
const nameVerFromPkgSnapshot_1 = require("./nameVerFromPkgSnapshot");
function extendProjectsWithTargetDirs(projects, lockfile, ctx) {
    const getLocalLocations = ctx.pkgLocationsByDepPath != null
        ? (depPath) => ctx.pkgLocationsByDepPath[depPath]
        : (depPath, pkgName) => [path_1.default.join(ctx.virtualStoreDir, (0, dependency_path_1.depPathToFilename)(depPath, ctx.virtualStoreDirMaxLength), 'node_modules', pkgName)];
    const projectsById = Object.fromEntries(projects.map((project) => [project.id, { ...project, targetDirs: [] }]));
    for (const [depPath, pkg] of Object.entries(lockfile.packages ?? {})) {
        if (pkg.resolution?.type !== 'directory')
            continue;
        const pkgId = (0, packageIdFromSnapshot_1.packageIdFromSnapshot)(depPath, pkg);
        const { name: pkgName } = (0, nameVerFromPkgSnapshot_1.nameVerFromPkgSnapshot)(depPath, pkg);
        const importerId = pkgId.replace(/^file:/, '');
        if (projectsById[importerId] == null)
            continue;
        const localLocations = getLocalLocations(depPath, pkgName);
        if (!localLocations)
            continue;
        projectsById[importerId].targetDirs.push(...localLocations);
        projectsById[importerId].stages = ['preinstall', 'install', 'postinstall', 'prepare', 'prepublishOnly'];
    }
    return Object.values(projectsById);
}
//# sourceMappingURL=extendProjectsWithTargetDirs.js.map